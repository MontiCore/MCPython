/* (c) https://github.com/MontiCore/monticore */
package de.monticore;

/*
 * The following utf-8 symbols are used to parse the Python files without having to add whitespace to the Grammar.
 * In a preprocessing step code blocks are denoted with \u204f = ⦃ and \u2984 = ⦄, and lines are ended with \u204f = ⁏  
 */

grammar Python extends  de.monticore.MultilineString, // Must be first to avoid conflicts with String token!
                        de.monticore.expressions.CommonExpressions,
    //                    de.monticore.expressions.BitExpressions, // For union
                        de.monticore.expressions.AssignmentExpressions,
                        de.monticore.literals.MCCommonLiterals,
                        de.monticore.symbols.OOSymbols {

  PythonScript = Statement*;

  @Override
  token SL_COMMENT = "#" (~('\n' | '\r' ))* : ->skip {storeComment();};
  token BLOCK_START = '\u2983';
  token BLOCK_END = '\u2984';
  token STATEMENT_END = ';'? '\u204f' | ';' '\u204f'?;

  token ByteOrderMark = '\uFEFF' : -> skip;

  // Will be filtered out by the WhitespacePreprocessingTokenSource
  // Used break a line without finishing the statement
  token CONTINUE_LINE_TOKEN = '\\' '\r'? '\n';

  // Often (mis)used as a multiline comment but can also be used as a string literal, thus we can not skip it
  token MultiLineStringToken = "f"? ((("\'\'\'") .*? ("\'\'\'")) | ((DoubleQuoteMultilineStringDelimiter .*? DoubleQuoteMultilineStringDelimiter))) ; // TODO: WORK ON ME : -> channel(HIDDEN);
  // TODO: Access the hidden channel
  MultiLineStringLiteral implements Literal = (type:key("u") | type:key("f") | type:key("b") |  | type:key("U") | type:key("F"))? MultiLineStringToken;

  // PEP 515: Underscores in Numeric Literals
  // TODO: Move this into its own token?
  @Override
  token Digits
    = Digit ('_'?  Digit)*; // technically the first digit must be nonzero except for 0(_0)*

  interface Statement;

  // The StatementBlock represents a number of statements with the same indentation
  // Here, C-Style brackets are used instead of indentation
  scope StatementBlock = BLOCK_START StatementBlockBody BLOCK_END;
  StatementBlockBody = Statement+;

  /*===========================Statements======================================*/
  ElseStatementPart = "else" ":" StatementBlock;

  PyQualifiedName = (Name || ".")+;
  astrule PyQualifiedName = method public String joined(){
    return String.join(".", getNameList());
  };

  // import statement
  ImportStatement implements Statement = ( "from" (leadingDots:"."+)? module:PyQualifiedName )? "import" (star:"*" | name:(PyQualifiedName || ",")+) ( "as" alias:Name )? STATEMENT_END;

  // if-else statement
  IfStatement implements Statement = "if"   condition:Expression     ":" thenStatement:StatementBlock
                                   ("elif" elifCondition:Expression ":" elifStatement:StatementBlock )*
                                   ElseStatementPart?;

  // assert statement
  AssertStatement implements Statement = "assert" condition:Expression ("," errorMessage:Expression)? STATEMENT_END;

  // for statement
  scope ForStatement implements Statement = "for" ForControl ":" StatementBlock
                                            ElseStatementPart? ;

  interface ForControl ;
  CommonForControl   implements ForControl =  ForVariable          "in" ForIterable ;
  UnpackedForControl implements ForControl = (ForVariable || ",")+ "in" ForIterable ;
  ParenUnpackedForControl implements ForControl = "(" (ForVariable || ",")+ ")" "in" ForIterable ;

  ForIterable = Expression;
  ForVariable implements Variable = Name;

  // while statement
  WhileStatement implements Statement = "while" condition:Expression ":" StatementBlock
                                      ElseStatementPart? ;

  BreakStatement implements Statement = "break" STATEMENT_END;
  ContinueStatement implements Statement = "continue" STATEMENT_END;

  // try-except-finally statement
  TryExceptStatement implements Statement = "try"                           ":" tryStatement:StatementBlock
                                          ExceptStatement+
                                                        ElseStatementPart ?
                                          ("finally"           ":" finallyStatement:StatementBlock )? ;

  ExceptStatement = ( "except" (Name? | "(" (Name || ",")+ ")") ("as" alias:Name)? ":" StatementBlock ) ;

  // with open file statement
  scope WithStatement implements Statement = "with" (WithStatementContents || ",")+ ":"
                                            StatementBlock ;

  WithStatementContents = Expression ("as" target:Name)? ; // target has slicing/etc

  // variable declaration statement
  LocalVariableDeclarationStatement implements Statement = VariableDeclaration STATEMENT_END;

  VariableDeclaration implements Variable = Name (((":" TypeAnnotation)? "=" VariableInit) |  (":" TypeAnnotation ("=" VariableInit)?) );

  GlobalVariableDeclaration implements Statement = "global" Name (":" TypeAnnotation)? STATEMENT_END;

  MultiVariableDeclaration implements Statement = (Name || ",")+ "=" Expression STATEMENT_END;
  ParenMultiVariableDeclaration implements Statement = "(" (Name || ",")+ ")" "=" Expression STATEMENT_END;

  interface VariableInit ;

  SimpleInit implements VariableInit = Expression ;

  ArrayLiteralExpression  implements Expression = "[" (VariableInit || ",")* ","? "]" ;
  TupleLiteralExpression  implements Expression = "(" (VariableInit || ",")* ","? ")" ;
  DictLiteralExpression   implements Expression = "{" (DictEntry || ",")* ","? "}" ;

  DictEntry = key:VariableInit ":" value:VariableInit ;

//  StarredExpression implements Expression = (Expression ",")+;


  // 6.3.3 - Slicing
  IndexExpression implements Expression = Expression "[" (IndexExpressionInner || ",")+ tuple:","? "]";

  // slice_item
  interface IndexExpressionInner;

  SimpleIndex implements IndexExpressionInner = Expression;
  // missing expressions are substituted by their default
  ProperSlice implements IndexExpressionInner = lower:Expression? ":" upper:Expression? (":" stride:Expression?)?;
 // AllIndex implements IndexExpressionInner = ":";
 // FromIndex implements IndexExpressionInner = from:Expression ":";
 // UntilIndex implements IndexExpressionInner = ":" until:Expression;
 // RangeIndex implements IndexExpressionInner = from:Expression (":"  step:Expression )? ":" until:Expression;

  // Walrus operator
  PyAssignmentExpression implements Expression = variable:Name operator:":=" right:Expression;

  // List/Set/Dict comprehension
  ListComprehensionExpression implements Expression = "[" Expression "for" ForControl GeneratorFilter? "]";
  SetComprehensionExpression implements Expression = "{" Expression "for" ForControl GeneratorFilter? "}";
  DictComprehensionExpression implements Expression = "{" Name ":" Expression "for" ForControl GeneratorFilter?  "}";
  GeneratorExpression implements Expression = Expression "for" ForControl GeneratorFilter? ;

  GeneratorFilter = "if" condition:Expression;

  // function declaration statement
  interface FunctionDeclaration extends Function = Name ;

  SimpleFunctionDeclaration implements FunctionDeclaration, Statement = PyDecorator* "def" Name "(" FunctionParameters ")" ("->" returnType:TypeAnnotation)? ":"
                                                        StatementBlock ;
  FunctionParameters = (FunctionParameter  || ",")* ","?;

  interface FunctionParameter;

  interface TypeAnnotation;
  StringTypeAnnotation      implements TypeAnnotation = StringLiteralPython;
  TupleTypeAnnotation       implements TypeAnnotation = "(" (TypeAnnotation || ",")+ ","? ")";
  QualifiedTypeAnnotation   implements TypeAnnotation = type:PyQualifiedName ("[" typeParams:(TypeAnnotation || ",")* "]")?;
  //ComplexTypeAnnotation     implements TypeAnnotation = Expression;

  SimpleFunctionParameter   implements FunctionParameter, Variable = Name (":" TypeAnnotation)?;
  OptionalFunctionParameter implements FunctionParameter, Variable = Name (":" TypeAnnotation)? "=" Expression ;
  VarArgFunctionParameter   implements FunctionParameter, Variable = "*" Name (":" TypeAnnotation)?;
  KWArgFunctionParameter    implements FunctionParameter, Variable = "**" Name (":" TypeAnnotation)?;
  StarFunctionParameter     implements FunctionParameter = "*";

  @Override
  Arguments = "("
    (Argument || ",")*
     ","?
  ")";

  interface Argument;
  NormalArgument implements Argument = Expression;
  NamedArgument implements Argument = paramName:Name "=" Expression;
  SpreadListArgument implements Argument = "*" Expression;
  SpreadMappingArgument implements Argument = "**" Expression;
  splittoken "**";

  // "@" assignment_expression NEWLINE
  //PyDecorator = "@" PyQualifiedName ("(" PyQualifiedName ")")? STATEMENT_END;
  PyDecorator = "@" Expression STATEMENT_END;

  // return statement
  ReturnStatement implements Statement = "return" (Expression || ",")* STATEMENT_END;

  RaiseStatement implements Statement = "raise" Expression? STATEMENT_END;

  // expression statement
  ExpressionStatement implements Statement = Expression ("," Expression)* STATEMENT_END;

  EmptyStatement implements Statement = STATEMENT_END;

  MatchStatement implements Statement = "match" Expression ":" MatchBlock;

  scope MatchBlock = BLOCK_START CaseStatement* BLOCK_END;
  CaseStatement = "case" (Expression || "|")+ ":" StatementBlock;

  ConditionalExecutionStatement implements Statement = "if" condition: Expression ":" Expression;

  /*===========================Literals======================================*/

  token RawStringDoubleQuote = 'r' '"' .*? '"';
  token RawStringSingleQuote = 'r' '\'' .*? '\'';

  // string literals for python
   token StringPython
      = '\'' (StringCharactersPython)? '\''
      : {setText(getText().substring(1, getText().length() - 1));};

  fragment token StringCharactersPython
    = (StringCharacterPython)+;

  fragment token StringCharacterPython
    = ~ ('\''| '\\') | PythonEscapeSequence;

  fragment token PythonEscapeSequence
       = '\\' ('b' | 't' | 'n' | 'f' | 'r' | '\'' | '\\')
         | OctalEscape | UnicodeEscape | '\\' 'x' HexDigit HexDigit;


    // TODO: type:key("R")
    // TODO: type:key("fr")
    // TODO: type:key("Fr")
    // TODO: type:key("fR")
    // TODO: type:key("rf")
    // TODO: type:key("rF")
    // TODO: type:key("Rf")
    // TODO: type:key("RF")

   StringLiteralPython implements Literal, SignedLiteral =
        (
            ( // Normal strings
                (type:key("u") | type:key("f") | type:key("b") |  | type:key("U") | type:key("F"))?
                (source:StringPython | source:String)
            )
            | RawStringDoubleQuote
            | RawStringSingleQuote
        )
        StringLiteralPython? // Python string concat: "abc" "def" => "abcdef"
        ;

  // boolean literals for python
  BooleanLiteralPython implements Literal, SignedLiteral =
      source:["True" | "False"];

  // https://docs.python.org/dev/library/constants.html#Ellipsis
  EllipsisLiteral implements Literal = "...";
  splittoken "...";

  token FloatWithExponent = (DigitsPart | PyFloat) ('e'|'E') ('+' | '-')? DigitsPart;
  FloatWithExponentLiteral implements NumericLiteral <100> = FloatWithExponent;

  token PyFloat = DigitsPart? '.' DigitsPart | DigitsPart '.';
  PyFloatLiteral implements NumericLiteral <200> = PyFloat;

  // PEP 515
  token DigitsPart = Digit ('_'? Digit)*;


  /*======================Expressions===========================================*/

  // ternary-operator expression
  TernaryOperatorExpression implements Expression <200> = thenExpression:Expression ( "if" condition:Expression
                                       "else" elseExpression:Expression )+ ;

  //mathematical expression
  IntegerDivisionExpression implements Expression <165>, InfixExpression = left:Expression  operator:"//" right:Expression ;
  IntegerPowExpression implements Expression <195>, InfixExpression = left:Expression operator:"**" right:Expression ;

  //logical expressions
  AndExpression implements Expression <120>, InfixExpression = left:Expression operator:"and" right:Expression ;
  OrExpression implements Expression <117>, InfixExpression = left:Expression operator:"or" right:Expression ;
  NotExpression implements Expression <190> = "not" Expression ;
  IsExpression implements Expression <130>, InfixExpression = left:Expression operator:"is" right:Expression ;
  InExpression implements Expression <195>, InfixExpression = left:Expression operator:"in" right:Expression ;
  NotInExpression implements Expression <195>, InfixExpression = left:Expression operator:"not in" right:Expression ;

  // lambda expression
  scope LambdaExpression implements Expression = "lambda" FunctionParameters ":" Expression ;
  AppliedLambdaExpression implements Expression = "(" LambdaExpression ")" "(" Expression ")" ;

  // TODO: Weird errors from antlr subsystem
  // IfExpression implements Expression = positive:Expression "if" condition:Expression "else" negative:Expression;

  /*===========================Classes======================================*/

  // class symbol
  interface scope symbol PythonClass = Name ;

  // class declaration statement
  ClassDeclaration implements PythonClass, Statement, ClassStatement = PyDecorator* "class" Name ( "(" superClass:PyQualifiedName? ")" )? ":" ClassStatementBlock ;

  interface ClassStatement;

  ClassStatementBlock = BLOCK_START ClassStatementBlockBody BLOCK_END;
  ClassStatementBlockBody = ClassStatement+;

  // TODO: Why is there 2 function declarations?
  ClassFunctionDeclaration implements FunctionDeclaration, ClassStatement = PyDecorator* "def" Name "(" ClassFunctionParameters ")" ("->" returnType:TypeAnnotation)? ":" StatementBlock;

  ClassFunctionParameters = (FunctionParameter || ",")* ","?;

  ClassAttributes implements ClassStatement = VariableDeclaration STATEMENT_END;

  ClassCommentStatement implements ClassStatement = MultiLineStringLiteral STATEMENT_END;

  @Override
  AssignmentExpression implements Expression <60> = <rightassoc>
    left:Expression ("," left:Expression)* ","?

    (":" annotated: Expression)? // borrowed from annotated_assignment_stmt

    operator: [ "=" | "+=" | "-=" | "*=" | "/=" | "&=" | "|="
              | "^=" | ">>=" | ">>>=" | "<<=" | "%=" ]
    right:Expression ("," right:Expression)* ","?;



}
