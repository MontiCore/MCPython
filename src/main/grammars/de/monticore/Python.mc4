/* (c) https://github.com/MontiCore/monticore */
package de.monticore;

grammar Python extends de.monticore.expressions.CommonExpressions,
                        de.monticore.expressions.AssignmentExpressions,
                        de.monticore.literals.MCCommonLiterals,
                        de.monticore.symbols.OOSymbols {

  PythonScript = (Statement | EOL)*;

  token SingleLineComment = "#" (~('\n' | '\r' ))*  : ->skip {storeComment();};

  // indentation token, 4 spaces or tabulator
  token Indent = "    " | "\t";

  // end of line token
  EOL = ("\n" | "\r")+ ;

  interface Statement ;

  // The StatementBlock represents a number of statements with the same indentation
  scope StatementBlock = EOL? StatementBlockBody {decreaseIndent()}? EOL? ;
  StatementBlockBody = Indent {isIndentedCorrectly()}? {increaseIndent()}? Indent* Statement
                            ( {isIndentedCorrectly()}?                     Indent+ Statement )* ;

  /*===========================Statements======================================*/

  // import statement
  ImportStatement implements Statement = ( "from" module:Name )? "import" (Name || ",")+ EOL ;

  // if-else statement
  IfStatement implements Statement = "if"   condition:Expression     ":" thenStatement:StatementBlock
                                   ( "elif" elifCondition:Expression ":" elifStatement:StatementBlock )*
                                   ( "else"                          ":" elseStatement:StatementBlock )?;

  // assert statement
  AssertStatement implements Statement = "assert" condition:Expression "," errorMessage:String EOL ;

  // for statement
  ForStatement implements Statement = "for" ForControl ":" StatementBlock
                                    ( "else"           ":" elseStatement:StatementBlock )? ;

  interface ForControl ;
  CommonForControl implements ForControl, Variable = Name "in" Expression ;
  ArrayForControl  implements ForControl, Variable = Name "in" ArrayInit ;

  // while statement
  WhileStatement implements Statement = "while" condition:Expression ":" StatementBlock
                                      ( "else"                       ":" elseStatement:StatementBlock )? ;

  // try-except-finally statement
  TryExceptStatement implements Statement = "try"                    ":" tryStatement:StatementBlock
                                            ExceptStatement+
                                          ( "else"                   ":" elseStatement:StatementBlock    )?
                                          ( "finally"                ":" finallyStatement:StatementBlock )? ;

  ExceptStatement = ( "except" Name? ":" StatementBlock ) ;

  // variable declaration statement
  LocalVariableDeclarationStatement implements Statement = VariableDeclaration EOL ;

  VariableDeclaration implements Variable = Name "=" VariableInit ;

  interface VariableInit ;

  SimpleInit implements VariableInit = Expression ;
  ArrayInit  implements VariableInit = "[" (VariableInit || ",")* "]" ;
  TupleInit  implements VariableInit = "(" (VariableInit || ",")* ")" ;


  // function declaration statement
  interface FunctionDeclaration extends Function = Name ;

  SimpleFunctionDeclaration implements Function, FunctionDeclaration, Statement = "def" Name "(" FunctionParameters ")" ":" EOL
                                                        StatementBlock ;
  FunctionParameters = (FunctionParameter  || ",")*;

  interface FunctionParameter extends Variable;

  SimpleFunctionParameter   implements FunctionParameter = Name ;
  OptionalFunctionParameter implements FunctionParameter = Name "=" Expression ;
  VarArgFunctionParameter   implements FunctionParameter = "*" Name ;

  // return statement
  ReturnStatement implements Statement = "return" Expression? EOL ;

  // expression statement
  ExpressionStatement implements Statement = Expression EOL ;

  // lambda statement
  LambdaStatement implements Statement = "lambda" FunctionParameters ":" Expression EOL ;

  /*===========================Literals======================================*/

  // string literals for python
   token StringPython
      = '\'' (StringCharactersPython)? '\''
      : {setText(getText().substring(1, getText().length() - 1));};

      fragment token StringCharactersPython
        = (StringCharacterPython)+;

      fragment token StringCharacterPython
        = ~ ('\''| '\\') | PythonEscapeSequence;

      fragment token PythonEscapeSequence
           = '\\' ('b' | 't' | 'n' | 'f' | 'r' | '\'' | '\\')
             | OctalEscape | UnicodeEscape;

   StringLiteralPython implements Literal, SignedLiteral =
       source:StringPython;

  // boolean
  BooleanLiteralPython implements Literal, SignedLiteral =
      source:["True" | "False"];

  /*======================Expressions===========================================*/

  // ternary-operator expression
  TernaryOperatorExpression implements Expression <200> = thenExpression:Expression ( "if" condition:Expression
                                       "else" elseExpression:Expression )+ ;

  //mathematical expression
  IntegerDivisionExpression implements Expression <180>, InfixExpression = left:Expression operator:" // " right:Expression ;
  IntegerPowExpression implements Expression <195>, InfixExpression = left:Expression operator:"**" right:Expression ;


  //logical expressions
  ANDExpression implements Expression <120>, InfixExpression = left:Expression operator:"and" right:Expression ;
  ORExpression implements Expression <117>, InfixExpression = left:Expression operator:"or" right:Expression ;
  ISExpression implements Expression <130>, InfixExpression = left:Expression operator:"is" right:Expression ;

  NOTExpression implements Expression <190> = "not" Expression ;



  /*===========================Classes======================================*/

  // class symbol
  interface scope symbol Class = Name ;

  // class declaration statement
  ClassDeclaration implements Class, Statement, ClassStatement = "class" Name ( "(" superClass:Name@Class? ")" )? ":" EOL ClassStatementBlock ;

  interface ClassStatement;

  ClassStatementBlock = EOL? ClassStatementBlockBody {decreaseIndent()}? EOL? ;
  ClassStatementBlockBody = Indent {isIndentedCorrectly()}? {increaseIndent()}? Indent* ClassStatement
                                 ( {isIndentedCorrectly()}?                     Indent+ ClassStatement )* ;

  ClassFunctionDeclaration implements Function, FunctionDeclaration, ClassStatement = "def" Name "(" ClassFunctionParameters ")" ":" StatementBlock EOL? ;

  ClassFunctionParameters = (SelfParameter ("," FunctionParameter)*) ;

  SelfParameter implements FunctionParameter = Name ;

  ClassAttributes implements ClassStatement = VariableDeclaration EOL ;

  /*==========================ANTLR=======================================*/
  /** This java code implements an indentation counter.
  *
  * isIndentedCorrectly() checks if the next symbols are exactly n indents, while n is equals to the indentCounter.
  + The method returns true if the previous condition is true, otherwise false.
  *
  * decreaseIndent() checks if the next symbols are indented correctly. If true, it returns false. Otherwise the indentCounter
  * will be decreased by one and the method returns true.
  *
  * increaseIndent() simply increases the indentCounter by one and always returns true.
  **/

  concept antlr {
    parserjava {
      public int indentCounter = 0;

      public boolean isIndentedCorrectly() {
        if (indentCounter == 0) {
          if (!cmpTokenRegEx(1, "    |\t")) {
            return true;
          } else {
            return false;
          }
        }
        return cmpTokenRegEx(indentCounter, "    |\t") && !cmpTokenRegEx(indentCounter + 1, "    |\t");
      }


      public boolean decreaseIndent() {
        if (isIndentedCorrectly()) {
          return false;
        }
        indentCounter--;
        return true;
      }

      public boolean increaseIndent() {
        indentCounter++;
        return true;
      }

    }
  }
}
