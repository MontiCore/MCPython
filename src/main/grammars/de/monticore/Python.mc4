/* (c) https://github.com/MontiCore/monticore */
package de.monticore;

/* This is a MontiCore alpha grammar. Adaptions are possible */

import de.monticore.MultilineString;
import de.monticore.expressions.*;
import de.monticore.literals.MCCommonLiterals;
import de.monticore.symbols.OOSymbols;

/**
 * The Python language defines an almost complete subset of the Python programming language.
 * The goal is to analyze existing Python (research) software; therefore, the grammar and CoCos are somewhat simplified.
 * Because the parsed code is assumed to be valid Python, as verified by other tools, certain restrictions can be omitted,
 * e.g., accepting code that is not strictly valid Python.
 * The focus is instead on building an abstract syntax that is easy to analyze within the MontiCore toolchain.
 */
grammar Python extends  MultilineString, // Must be first to avoid conflicts with String token!
                        CommonExpressions,
                        AssignmentExpressions,
                        MCCommonLiterals,
                        OOSymbols {

  PythonScript = Statement*;

  /*====================================== Tokens ======================================*/
  @Override
  token WS = (' ' | '\t' | '\r' | '\n' ) : -> channel(HIDDEN);
  @Override
  token SL_COMMENT = "#" (~('\n' | '\r' ))* : -> channel(HIDDEN);
  token ByteOrderMark = '\uFEFF' : -> skip;

  /**
   * The following utf-8 symbols are used to parse the Python files without having to add whitespace to the Grammar.
   * In a preprocessing step code blocks are denoted with \u204f = ⦃ and \u2984 = ⦄, and lines are ended with \u204f = ⁏
   */
  token BLOCK_START = '\u2983';
  token BLOCK_END = '\u2984';
  token STATEMENT_END = ';'? '\u204f' | ';' '\u204f'?;

  // Will be filtered out by the WhitespacePreprocessingTokenSource
  // Used break a line without finishing the statement
  token CONTINUE_LINE_TOKEN = '\\' '\r'? '\n';

  // === string tokens for python ===
  // Often (mis)used as a multiline comment but can also be used as a string literal, thus we can not skip it
  token MultiLineStringToken = ((("\'\'\'") .*? ("\'\'\'")) | ((DoubleQuoteMultilineStringDelimiter .*? DoubleQuoteMultilineStringDelimiter)));

  @Override
  token String = '"' (StringDQCharactersPython)? '"' : {setText(getText().substring(1, getText().length() - 1));};

  token StringPython
    = '\'' (StringSQCharactersPython)? '\''
    : {setText(getText().substring(1, getText().length() - 1));};

  fragment token StringSQCharactersPython
    = (StringSQCharacterPython)+;
  fragment token StringDQCharactersPython
    = (StringDQCharacterPython)+;

  fragment token StringSQCharacterPython
    = ~ ('\''| '\\' | '\n') | PythonEscapeSequence;
  fragment token StringDQCharacterPython
    = ~ ('"'| '\\' | '\n') | PythonEscapeSequence;

  fragment token PythonEscapeSequence
       = '\\' .;

  // === number tokens for python ===

  token FloatWithExponent = (DigitsPart | PyFloat) ('e'|'E') ('+' | '-')? DigitsPart;
  FloatWithExponentLiteral implements NumericLiteral <100> = FloatWithExponent;

  token PyFloat = DigitsPart? '.' DigitsPart | DigitsPart '.';
  PyFloatLiteral implements NumericLiteral <200> = PyFloat;

  // PEP 515
  token DigitsPart = Digit ('_'? Digit)*;

  token HexNumberToken = '0' 'x' ('0'..'9' | 'a'..'f' | 'A'..'F')+;
  // PEP 515: Underscores in Numeric Literals
  @Override
  token Digits
    = Digit ('_'?  Digit)*; // technically the first digit must be nonzero except for 0(_0)*

  /*====================================== Literals ======================================*/

  HexNumberLiteral implements NumericLiteral <100> = HexNumberToken;

  ArrayLiteral implements Literal = "[" (VariableInit || ",")* ","? "]" ;
  TupleLiteral implements Literal = "(" (VariableInit || ",")* ","? ")" ;
  DictLiteral implements Literal = "{" (DictEntry || ",")* ","? "}" ;
  SetLiteral implements Literal = "{" (Expression || ",")* ","? "}" ;

  DictEntry = key:VariableInit ":" value:VariableInit | SpreadMappingExpression;

  StringLiteralPython implements Literal, SignedLiteral =
          (
              StringModifier?
              (source:StringPython | source:String)
          );

  StringsLiteralPython implements Literal <200> = (StringLiteralPython | StringLiteral | MultiLineStringLiteral)+;

  StringModifier = /*{cmpTokenRegEx(1, "(f|r|b|u|F|R|B|U)+")}?*/ type:Name;
  MultiLineStringLiteral implements Literal = StringModifier? MultiLineStringToken;

  // boolean literals for python
  BooleanLiteralPython implements Literal, SignedLiteral =
      source:["True" | "False"];

  // https://docs.python.org/dev/library/constants.html#Ellipsis
  EllipsisLiteral implements Literal = "...";
  splittoken "...";

  /*====================================== Statements ======================================*/
  interface Statement;

  // The StatementBlock represents a number of statements with the same indentation
  scope StatementBlock = (BLOCK_START StatementBlockBody BLOCK_END) | Statement;
  StatementBlockBody = Statement+;

  LiteralStatement implements ClassStatement = Literal STATEMENT_END;

  PassStatement implements Statement, ClassStatement = "pass" STATEMENT_END;

  ElseStatementPart = "else" ":" StatementBlock;

  PyQualifiedName = (Name || ".")+;
  astrule PyQualifiedName = method public String joined(){
    return String.join(".", getNameList());
  };

  // import statement
  ImportStatement implements Statement =
      ("from" {!next("import")}? (leadingDots:"."*) (module:PyQualifiedName)?)?
      "import"
          (
              ModuleList
              | paren:"(" ModuleList ")"
          )
      STATEMENT_END;

  ModuleList = star:"*" | ((ModuleWithOptionalAlias || ",")+ ","?);

  ModuleWithOptionalAlias = name:PyQualifiedName ("as" alias:Name)?;


  // if-else statement
  IfStatement implements Statement = "if"   condition:Expression     ":" thenStatement:StatementBlock
                                   ("elif" elifCondition:Expression ":" elifStatement:StatementBlock )*
                                   ElseStatementPart?;

  // assert statement
  AssertStatement implements Statement = "assert" condition:Expression ("," errorMessage:Expression)? STATEMENT_END;

  // for statement
  scope ForStatement implements Statement = async:"async"? "for" ForControl ":" StatementBlock
                                            ElseStatementPart? ;

  ForControl = ForDecomposition "in" ForIterable;
  interface ForDecomposition;
  ForVariable implements Variable, ForDecomposition = Name;
  ForDecompositionComma implements ForDecomposition = ForDecomposition "," (ForDecomposition ","?)?;
  ForDecompositionParenthesis implements ForDecomposition = "(" ForDecomposition ")";

  ForIterable = Expression;

  // while statement
  WhileStatement implements Statement = "while" condition:Expression ":" StatementBlock
                                      ElseStatementPart? ;

  BreakStatement implements Statement = "break" STATEMENT_END;
  ContinueStatement implements Statement = "continue" STATEMENT_END;

  // try-except-finally statement
  TryExceptStatement implements Statement = "try" ":" tryStatement:StatementBlock
                                              (
                                                  (
                                                        ExceptStatement+
                                                        ElseStatementPart?
                                                        FinallyStatement?
                                                  )
                                                  | FinallyStatement
                                              )
                                          ;

  ExceptStatement = "except" (PyQualifiedName? | "(" (PyQualifiedName || ",")+ ")") ("as" alias:Name)? ":" StatementBlock;
  FinallyStatement = "finally" ":" finallyStatement:StatementBlock;

  // with open file statement
  scope WithStatement implements Statement = async:"async"? "with" (WithStatementContents || ",")+ ":"
                                            StatementBlock ;

  WithStatementContents = Expression ("as" target:Name)? ; // target has slicing/etc

  // variable declaration statement
  LocalVariableDeclarationStatement implements Statement = VariableDeclaration STATEMENT_END;

  VariableDeclaration implements Variable = Name (
    ((":" TypeAnnotation)? "=" VariableInit)
    |
    (":" TypeAnnotation)
  );

  GlobalVariableDeclaration implements Statement = "global" Name (":" TypeAnnotation)? STATEMENT_END;

  MultiVariableDeclaration implements Statement = (Name || ",")+ ","? "=" Expression STATEMENT_END;
  ParenMultiVariableDeclaration implements Statement = "(" (Name || ",")+ ","? ")" "=" Expression STATEMENT_END;

  interface VariableInit ;

  SimpleInit implements VariableInit = Expression ;

  // function declaration statement
  interface FunctionDeclaration extends Function = Name ;

  SimpleFunctionDeclaration implements FunctionDeclaration, Statement = PyDecorator* async:"async"? "def" Name "(" FunctionParameters ")" ("->" returnType:TypeAnnotation)? ":"
                                                        StatementBlock ;
  FunctionParameters = (FunctionParameter  || ",")* ","?;

  interface FunctionParameter;
  SimpleFunctionParameter   implements FunctionParameter, Variable = Name (":" TypeAnnotation)?;
  OptionalFunctionParameter implements FunctionParameter, Variable = Name (":" TypeAnnotation)? "=" Expression ;
  VarArgFunctionParameter   implements FunctionParameter, Variable = "*" Name (":" TypeAnnotation)?;
  KWArgFunctionParameter    implements FunctionParameter, Variable = "**" Name (":" TypeAnnotation)?;
  StarFunctionParameter     implements FunctionParameter = "*";

  @Override
  Arguments = "("
    (Argument || ",")*
     ","?
  ")";

  interface Argument;
  NormalArgument implements Argument = Expression;
  NamedArgument implements Argument = paramName:Name "=" Expression;

  PyDecorator = "@" Expression STATEMENT_END;

  ReturnStatement implements Statement = "return" (Expression || ",")* ","? STATEMENT_END;
  YieldStatement implements Statement = "yield" (Expression || ",")* ","? STATEMENT_END;
  RaiseStatement implements Statement = "raise" (Expression ("from" Name)?)? STATEMENT_END;

  ExpressionStatement implements Statement = Expression ("," Expression)* STATEMENT_END;

  EmptyStatement implements Statement, ClassStatement = STATEMENT_END;

  MatchStatement implements Statement = key("match") Expression ":" MatchBlock;

  scope MatchBlock = BLOCK_START CaseStatement* BLOCK_END;
  CaseStatement = key("case") (Expression || "|")+ ("if" condition:Expression)? ":" StatementBlock;

  ConditionalExecutionStatement implements Statement = "if" condition: Expression ":" Expression;

  DeleteStatement implements Statement = "del" (Expression || ",")+ ","? STATEMENT_END;

  /*====================================== Expressions ======================================*/

  SpreadListExpression implements Expression = "*" Expression;
  SpreadMappingExpression implements Expression = "**" Expression;
  splittoken "**";

  // ternary-operator expression
  TernaryOperatorExpression implements Expression <200> = thenExpression:Expression ( "if" condition:Expression
                                       "else" elseExpression:Expression )+ ;

  //mathematical expression
  IntegerDivisionExpression implements Expression <165>, InfixExpression = left:Expression  operator:"//" right:Expression ;
  IntegerPowExpression implements Expression <195>, InfixExpression = left:Expression operator:"**" right:Expression ;
  MatrixMultiplicationExpression implements Expression <200>, InfixExpression = left:Expression operator:"@" right:Expression;

  //logical expressions
  AndExpression implements Expression <120>, InfixExpression = left:Expression operator:"and" right:Expression ;
  OrExpression implements Expression <117>, InfixExpression = left:Expression operator:"or" right:Expression ;
  NotExpression implements Expression <10> = "not" Expression ;
  IsExpression implements Expression <130>, InfixExpression = left:Expression operator:"is" right:Expression ;
  InExpression implements Expression <195>, InfixExpression = left:Expression operator:"in" right:Expression ;
  NotInExpression implements Expression <195>, InfixExpression = left:Expression operator:"not" "in" right:Expression; // TODO: set operator to "not in" programmatically

  //Bitwise expressions
  BitwiseAndExpression implements Expression <120>, InfixExpression = left:Expression operator:"&" right:Expression;
  BitwiseOrExpression implements Expression <120>, InfixExpression = left:Expression operator:"|" right:Expression;
  BitwiseXOrExpression implements Expression <120>, InfixExpression = left:Expression operator:"^" right:Expression;
  BitwiseLeftShiftExpression implements Expression <120>, InfixExpression = left:Expression operator:"<<" right:Expression;
  BitwiseRightShiftExpression implements Expression <120>, InfixExpression = left:Expression operator:">>" right:Expression;

  BitwiseOnesComplimentExpression implements Expression <120> = "~" Expression;

  // lambda expression
  scope LambdaExpression implements Expression = "lambda" FunctionParameters ":" Expression ;
  AppliedLambdaExpression implements Expression = "(" LambdaExpression ")" "(" Expression ")" ;

  AwaitExpression implements Expression = "await" Expression;

  AnnotatedAssignmentExpression implements Expression <60> = <rightassoc>
      left:Expression
      ":" annotated: TypeAnnotation
      operator: [ "=" | "+=" | "-=" | "*=" | "/=" | "&=" | "|="
                | "^=" | ">>=" | ">>>=" | "<<=" | "%=" ]
      right:Expression;

  UnpackingAssignmentExpression implements Expression <60> = <rightassoc>
    "(" left:Expression ("," left:Expression)* ","? ")" "="
    right: Expression;

  // 6.3.3 - Slicing
  IndexExpression implements Expression = Expression "[" (IndexExpressionInner || ",")+ tuple:","? "]";

  // slice_item
  interface IndexExpressionInner;

  SimpleIndex implements IndexExpressionInner = Expression;
  ProperSlice implements IndexExpressionInner = lower:Expression? ":" upper:Expression? (":" stride:Expression?)?;

  // Walrus operator
  PyAssignmentExpression implements Expression = variable:Name operator:":=" right:Expression;

  // List/Set/Dict comprehension
  ListComprehensionExpression implements Expression = "[" Expression "for" ForControl GeneratorFilter? "]";
  SetComprehensionExpression implements Expression = "{" Expression "for" ForControl GeneratorFilter? "}";
  DictComprehensionExpression implements Expression = "{" Name ":" Expression "for" ForControl GeneratorFilter?  "}";
  GeneratorExpression implements Expression = Expression "for" ForControl GeneratorFilter? ;

  GeneratorFilter = "if" condition:Expression;

  /*===========================Classes======================================*/

  // class symbol
  interface scope symbol PythonClass = Name ;

  // class declaration statement
  ClassDeclaration implements PythonClass, Statement, ClassStatement = PyDecorator* "class" Name ( "(" ((superClasses:PyQualifiedName TypeAnnotation? | arguments:NamedArgument) ","?)* ")" )? ":" ClassStatementBlock ;

  interface ClassStatement;

  ClassStatementBlock = BLOCK_START ClassStatementBlockBody BLOCK_END;
  ClassStatementBlockBody = ClassStatement+;

  ClassFunctionDeclaration implements FunctionDeclaration, ClassStatement = PyDecorator* async:"async"? "def" Name "(" ClassFunctionParameters ")" ("->" returnType:TypeAnnotation)? ":" StatementBlock;

  ClassFunctionParameters = (FunctionParameter || ",")* ","?;

  ClassAttributes implements ClassStatement = VariableDeclaration STATEMENT_END;

  ClassCommentStatement implements ClassStatement = MultiLineStringLiteral STATEMENT_END;

  /*====================================== Type Annotations ======================================*/

  interface TypeAnnotation;
  StringTypeAnnotation      implements TypeAnnotation = StringLiteralPython;
  TupleTypeAnnotation       implements TypeAnnotation = "(" (TypeAnnotation || ",")+ ","? ")";
  QualifiedTypeAnnotation   implements TypeAnnotation = type:PyQualifiedName ("[" typeParams:(TypeAnnotation || ",")* "]")?;
  AlternativeTypeAnnotation implements TypeAnnotation = <rightassoc> lhs:TypeAnnotation "|" rhs:TypeAnnotation;
  CommaTypeAnnotation       implements TypeAnnotation = <rightassoc> lhs:TypeAnnotation "," rhs:TypeAnnotation ","?;
  ListTypeAnnotation        implements TypeAnnotation = "[" TypeAnnotation "]";
  EllipsisTypeAnnotation    implements TypeAnnotation = "...";
  ComplexTypeAnnotation     implements TypeAnnotation <200> = Expression;
}
