/* (c) https://github.com/MontiCore/monticore */
package de.monticore;

grammar Python extends  de.monticore.MultilineString, // Must be first to avoid conflicts with String token!
                        de.monticore.expressions.CommonExpressions,
                        de.monticore.expressions.AssignmentExpressions,
                        de.monticore.literals.MCCommonLiterals,
                        de.monticore.symbols.OOSymbols {

  PythonScript = Statement*;

  token SingleLineComment = "#" (~('\n' | '\r' ))* : ->skip {storeComment();};

  // Often (mis)used as a multiline comment but can also be used as a string literal, this we can not skip it
  token MultiLineStringToken = ((("\'\'\'") .*? ("\'\'\'")) | ((DoubleQuoteMultilineStringDelimiter .*? DoubleQuoteMultilineStringDelimiter)));
  MultiLineStringLiteral implements Literal = MultiLineStringToken;

  interface Statement;

  // The StatementBlock represents a number of statements with the same indentation
  // Here, C-Style brackets are used instead of indentation
  scope StatementBlock = "\u2983" StatementBlockBody "\u2984";
  StatementBlockBody = Statement+;

  /*===========================Statements======================================*/
  ElseStatementPart = "else" ":" StatementBlock;

  // import statement
  ImportStatement implements Statement = ( "from" module:Name )? "import" (Name || ",")+ ( "as" alias:Name )? "\u204f";

  // if-else statement
  IfStatement implements Statement = "if"   condition:Expression     ":" thenStatement:StatementBlock
                                   ("elif" elifCondition:Expression ":" elifStatement:StatementBlock )*
                                   ElseStatementPart?;

  // assert statement
  AssertStatement implements Statement = "assert" condition:Expression "," errorMessage:String "\u204f";

  // for statement
  scope ForStatement implements Statement = "for" ForControl ":" StatementBlock
                                            ElseStatementPart? ;

  interface ForControl ;
  CommonForControl   implements ForControl =  ForVariable          "in" ForIterable ;
  UnpackedForControl implements ForControl = (ForVariable || ",")+ "in" ForIterable ;

  ForIterable = Expression | ArrayInit;
  ForVariable implements Variable = Name;

  // while statement
  WhileStatement implements Statement = "while" condition:Expression ":" StatementBlock
                                      ElseStatementPart? ;

  BreakStatement implements Statement = "break" "\u204f";
  ContinueStatement implements Statement = "continue" "\u204f";

  // try-except-finally statement
  TryExceptStatement implements Statement = "try"                           ":" tryStatement:StatementBlock
                                          ExceptStatement+
                                                        ElseStatementPart ?
                                          ("finally"           ":" finallyStatement:StatementBlock )? ;

  ExceptStatement = ( "except" Name? ":" StatementBlock ) ;

  // with open file statement
  scope WithOpenFileStatement implements Statement = "with" (OpenFileExpression || ",")+ ":"
                                            StatementBlock ;

  OpenFileExpression = Expression "as" fileName:Name ;

  // variable declaration statement
  LocalVariableDeclarationStatement implements Statement = VariableDeclaration "\u204f";

  VariableDeclaration implements Variable = Name "=" VariableInit ;

  interface VariableInit ;

  SimpleInit implements VariableInit = Expression ;
  ArrayInit  implements VariableInit = "[" (VariableInit || ",")* "]" ;
  TupleInit  implements VariableInit = "(" (VariableInit || ",")* ")" ;
  DictInit   implements VariableInit = "{" (DictEntry || ",")* "}" ;
  DictEntry = key:VariableInit ":" value:VariableInit ;

  // function declaration statement
  interface FunctionDeclaration extends Function = Name ;

  SimpleFunctionDeclaration implements FunctionDeclaration, Statement = "def" Name "(" FunctionParameters ")" ":"
                                                        StatementBlock ;
  FunctionParameters = (FunctionParameter  || ",")*;

  interface FunctionParameter extends Variable;

  SimpleFunctionParameter   implements FunctionParameter = Name ;
  OptionalFunctionParameter implements FunctionParameter = Name "=" Expression ;
  VarArgFunctionParameter   implements FunctionParameter = "*" Name ;

  // return statement
  ReturnStatement implements Statement = "return" Expression? "\u204f";

  RaiseStatement implements Statement = "raise" Expression? "\u204f";

  // expression statement
  ExpressionStatement implements Statement = Expression "\u204f";

  /*===========================Literals======================================*/

  // string literals for python
   token StringPython
      = '\'' (StringCharactersPython)? '\''
      : {setText(getText().substring(1, getText().length() - 1));};

      fragment token StringCharactersPython
        = (StringCharacterPython)+;

      fragment token StringCharacterPython
        = ~ ('\''| '\\') | PythonEscapeSequence;

      fragment token PythonEscapeSequence
           = '\\' ('b' | 't' | 'n' | 'f' | 'r' | '\'' | '\\')
             | OctalEscape | UnicodeEscape;

   StringLiteralPython implements Literal, SignedLiteral =
       source:StringPython;

  // boolean literals for python
  BooleanLiteralPython implements Literal, SignedLiteral =
      source:["True" | "False"];

  /*======================Expressions===========================================*/

  // ternary-operator expression
  TernaryOperatorExpression implements Expression <200> = thenExpression:Expression ( "if" condition:Expression
                                       "else" elseExpression:Expression )+ ;

  //mathematical expression
  IntegerDivisionExpression implements Expression <180>, InfixExpression = left:Expression operator:" // " right:Expression ;
  IntegerPowExpression implements Expression <195>, InfixExpression = left:Expression operator:"**" right:Expression ;

  //logical expressions
  AndExpression implements Expression <120>, InfixExpression = left:Expression operator:"and" right:Expression ;
  OrExpression implements Expression <117>, InfixExpression = left:Expression operator:"or" right:Expression ;
  NotExpression implements Expression <190> = "not" Expression ;
  IsExpression implements Expression <130>, InfixExpression = left:Expression operator:"is" right:Expression ;
  InExpression implements Expression <195>, InfixExpression = left:Expression operator:"in" right:Expression ;
  NotInExpression implements Expression <195>, InfixExpression = left:Expression operator:"not in" right:Expression ;

  // lambda expression
  scope LambdaExpression implements Expression = "lambda" FunctionParameters ":" Expression ;
  AppliedLambdaExpression implements Expression = "(" LambdaExpression ")" "(" Expression ")" ;


  /*===========================Classes======================================*/

  // class symbol
  interface scope symbol PythonClass = Name ;

  // class declaration statement
  ClassDeclaration implements PythonClass, Statement, ClassStatement = "class" Name ( "(" superClass:Name@PythonClass? ")" )? ":" ClassStatementBlock ;

  interface ClassStatement;

  ClassStatementBlock = "\u2983" ClassStatementBlockBody "\u2984";
  ClassStatementBlockBody = ClassStatement+;

  ClassFunctionDeclaration implements FunctionDeclaration, ClassStatement = "def" Name "(" ClassFunctionParameters ")" ":" StatementBlock;

  ClassFunctionParameters = (SelfParameter ("," FunctionParameter)*) ;

  SelfParameter implements FunctionParameter = Name ;

  ClassAttributes implements ClassStatement = VariableDeclaration "\u204f";
}
